#!/bin/sh

path=$(git rev-parse --git-dir 2>/dev/null)
# path=$(cd "${relative_path}" &>/dev/null && printf "%s" "$PWD")

in_repo=$([ "$path" ] && [ "$path" != "/.git" ] && [ "$path" != "~" ] && [ "$path" != "${HOME}/.git" ] && echo "true" || echo "false")

if [ ${in_repo} == "false" ]; then
  echo ""
else
  qualified_branch=$(cat "${path}/HEAD" | grep "refs/heads/")
  branch=${qualified_branch#*refs/heads/}

  head_ref=$(git rev-parse --short HEAD 2>/dev/null)

  cwd_dirty=$([ "$path" != "." ] && [ "$(git status --porcelain)" != "" ] && echo " %{\e[90m%}âœ—%{\e[0m%}")

  if [ -e "${path}/BISECT_LOG" ]; then
    rebasing_etc="+bisect"
  elif [ -e "${path}/MERGE_HEAD" ]; then
    rebasing_etc="+merge"
  elif [ -e "${path}/rebase" ] || [ -e "${path}/rebase-apply" ] || [ -e "${path}/rebase-merge" ] || [ -e "${path}/../.dotest" ]; then
    rebasing_etc="+rebase"
  else
    rebasing_etc=""
  fi

  gecho -e " %{\e[34m%}${branch}%{\e[90m%}@%{\e[33m%}${head_ref}%{\e[0m%}${rebasing_etc}${cwd_dirty}"
fi
