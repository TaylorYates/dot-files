#!/bin/sh

path=$(git rev-parse --git-dir 2>/dev/null)

in_repo=$([ "$path" ] && [ "$path" != "/.git" ] && [ "$path" != "~" ] && [ "$path" != "${HOME}/.git" ] && echo "true" || echo "false")

if [ ${in_repo} == "false" ]; then
  echo ""
else
  qualified_branch=$(cat "${path}/HEAD" | grep "refs/heads/")
  branch=${qualified_branch#*refs/heads/}

  head_ref=$(git rev-parse --short HEAD 2>/dev/null)

  cwd_dirty=$([ "$path" != "." ] && [ "$(git status --porcelain)" != "" ] && echo " %{\e[90m%}âœ—" || echo "")

  if [ -e "${path}/BISECT_LOG" ]; then
    rebasing_etc="%{\e[90m%}, bisecting"
  elif [ -e "${path}/MERGE_HEAD" ]; then
    rebasing_etc="%{\e[90m%}, merging"
  elif [ -e "${path}/rebase" ] || [ -e "${path}/rebase-apply" ] || [ -e "${path}/rebase-merge" ] || [ -e "${path}/../.dotest" ]; then
    rebasing_etc="%{\e[90m%}, rebasing"
  else
    rebasing_etc=""
  fi

  if [ "${branch}" == "" ]; then
    gecho -en " %{\e[33m%}${head_ref}%{\e[90m%}, detached"
  else
    gecho -en " %{\e[34m%}${branch}%{\e[90m%}@%{\e[33m%}${head_ref}"
  fi

  gecho -e "${rebasing_etc}${cwd_dirty}%{\e[0m%}"
fi
